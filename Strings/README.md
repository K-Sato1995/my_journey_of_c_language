# Strings
Ｃ言語では`char型(文字型)`(char は character の略）というデータ型がある。これは1バイトのメモリサイズをもつデータ型である。コンピュータのメモリアクセスは，1バイトが最小の単位であるから，char 型は最小のメモリサイズを持つ型であると言える。

## `配列`で表す文字列  
C言語では`Strings`は実はこの`characters`の`配列`ある。

また、これは単なる文字列ではなく、「文字列の最後には終端を表す文字 '\0'（ヌル文字）がついている」という約束の下に取り扱われる文字`配列`である。

以下の方法で書換える事の出来ない`string`を定義できる。
下記の`[](空のカッコ)`はコンパイラに`配列`のサイズを自動で数えさせる事を意味している。

```c
char name[]= "Jack";
/* is the same as */
char name[5] = "Jack"; //ヌル文字文を`配列`のサイズに含める。
```

## ポインタで表す文字列
文字列リテラルは、プログラムの実行開始から終了まで常にメモリ上に存在する、という特徴がある。
`配列`の初期化時に文字列リテラルを指定すると、その文字列の長さ分(プラスNULL文字)のサイズを持つ`配列`が自動的に生成され、そこに一文字ずつ値がコピーされる。
文字列リテラルは、プログラムの実行開始から終了まで常にメモリ上に存在する、という特徴があります。
`配列`の初期化時に文字列リテラルを指定すると、その文字列の長さ分(プラスNULL文字)のサイズを持つ`配列`が自動的に生成され、そこに一文字ずつ値がコピーされます。
文字列は`ポインタ`を使用すると以下の様に定義できる。

```c
char *name;
```

### ポインタを使用する利点
`ポインタ`を使用して定義した文字列は、代入だけで変更可能である。

```c
char str[] = "ABCD";
char *strP = "EFGH";
char *strP2;

//これはNG
str = "IJKL";

//これはOK
strP = "IJKLMNOPQRSTU";

//これもOK
strP2 = strP;
```


### 配列を使用する利点

文字列`配列`のときは、5行目のように文字列を書き換える事ができる。
`配列`は、文字列リテラルとは別の場所に容量を確保し、そこに値を保存しているため、書き換えても問題はない。
しかし、`ポインタ`が指し示すのは文字列リテラル自身であり、文字列リテラルは書き換えてはならないというルールがあるため、書き換えは不可能。


```c
char str[] = "ABCD";
char *strP = "EFGH";

//これはOK
str[1] = 'Z';

//これはNG
strP[1] = 'Z';

//こうやってもNG
*(strP + 1) = 'Z';
```

# References
- [`ポインタ`と文字列](https://programming.pc-note.net/c/pointer4.html)
